/*************************************************************************
  > File Name: 6-4.cpp
  > Author: wolf
  > Mail: wolfguidao@163.com 
  > Created Time: 2020年05月29日 星期五 16时32分51秒
 ************************************************************************/

#include "Header.hpp"

int main()
{
  int n;
  cin >> n;

  vector<int> arr(n);
  vector<int> dp(n);//保存从前往后和从后往前遍历的结果

  for (int i = 0; i < n; i++)
    cin >> arr[i];

  stack<int> l,r;//单调栈

  //从后往前遍历
  for(int i = n - 1;i > 0;i--)
  {
    //如果当前元素值大于等于栈顶元素，说明：
    //前一个元素的值大于后一个元素的值
    //那么就代表从前面往后看的时候是被前面大的元素给挡住了
    //所以直接pop
    while(!r.empty() && arr[i] >= r.top())
    {
      r.pop();
    }
    //放入当前元素
    r.push(arr[i]);
    //因为如果当前元素能够成功挡住后面的元素，只是相对于当前元素的前一个元素
    //而言的，因为如果是相对于当前元素来说，当前元素大并不能挡住后面值小的
    //元素，直接就可以看到
    //所以栈中的元素个数是相对于当前位置的前一个位置：i - 1
    dp[i - 1] = r.size();
  }

  //因为从后往前遍历的时候只是遍历到1，在1的时候就把0位置后面比其
  //大的元素个数求出来了，但是并没有包含自己，所以需要加1
  dp[0] += 1;

  //同理
  for(int i = 0;i < n - 1;i++)
  {
    while(!l.empty() && arr[i] >= l.top())
    {
      l.pop();
    }
    l.push(arr[i]);
    dp[i + 1] += l.size() + 1;
  }

  for(auto e : dp)
  {
    cout<<e<<" ";
  }
  cout<<endl;
  return 0;
}

